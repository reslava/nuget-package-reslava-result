using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using REslava.Result.SourceGenerators.Core.Interfaces;
using REslava.Result.SourceGenerators.Generators.SmartEndpoints.Models;
using System.Text;
using System.Linq;
using System.Collections.Generic;

namespace REslava.Result.SourceGenerators.Generators.SmartEndpoints.CodeGeneration
{
    /// <summary>
    /// Generates SmartEndpoint extension methods and endpoint registration code.
    /// Single Responsibility: Only generates the endpoint mapping code.
    /// </summary>
    public class SmartEndpointExtensionGenerator : ICodeGenerator
    {
        public SourceText GenerateCode(Compilation compilation, object config)
        {
            System.Diagnostics.Debug.WriteLine("üöÄ SmartEndpointExtensionGenerator.GenerateCode called!");

            // Use provided endpoint metadata if available, otherwise do discovery
            List<EndpointMetadata> endpoints = null;
            
            if (config is List<EndpointMetadata> providedEndpoints && providedEndpoints.Any())
            {
                System.Diagnostics.Debug.WriteLine($"‚úÖ Using provided endpoint metadata: {providedEndpoints.Count} endpoints");
                endpoints = providedEndpoints;
            }
            else
            {
                System.Diagnostics.Debug.WriteLine("üîç No endpoint metadata provided, doing discovery...");
                // Scan for classes and methods with SmartEndpoints attributes
                var controllers = DiscoverControllers(compilation);
                
                if (!controllers.Any())
                {
                    System.Diagnostics.Debug.WriteLine("‚ö†Ô∏è No controllers found with SmartEndpoints attributes");
                    return SourceText.From("// No SmartEndpoints found", Encoding.UTF8);
                }
                
                // Extract endpoints from controllers
                endpoints = new List<EndpointMetadata>();
                foreach (var controller in controllers)
                {
                    endpoints.AddRange(controller.Endpoints);
                }
                
                System.Diagnostics.Debug.WriteLine($"üîç Discovered {endpoints.Count} endpoints");
            }

            if (!endpoints.Any())
            {
                System.Diagnostics.Debug.WriteLine("‚ö†Ô∏è No endpoints found");
                return SourceText.From("// No SmartEndpoints found", Encoding.UTF8);
            }

            var builder = new StringBuilder();

            // Add using statements
            builder.AppendLine("using Microsoft.AspNetCore.Builder;");
            builder.AppendLine("using Microsoft.AspNetCore.Http;");
            builder.AppendLine("using Microsoft.AspNetCore.Routing;");
            builder.AppendLine("using REslava.Result;");
            builder.AppendLine("using REslava.Result.AdvancedPatterns;");
            builder.AppendLine("using MinimalApi.Net10.REslavaResult.Models;");
            builder.AppendLine("using Generated.OneOfExtensions;");
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Threading.Tasks;");
            builder.AppendLine();

            // Generate namespace
            builder.AppendLine("namespace Generated.SmartEndpoints");
            builder.AppendLine("{");
            builder.AppendLine("    /// <summary>");
            builder.AppendLine("    /// Auto-generated endpoint registration extensions.");
            builder.AppendLine("    /// Generated by REslava.Result.SourceGenerators.SmartEndpoints.");
            builder.AppendLine("    /// </summary>");
            builder.AppendLine("    public static class SmartEndpointExtensions");
            builder.AppendLine("    {");

            // Generate MapSmartEndpoints method
            GenerateMapSmartEndpointsMethod(builder, endpoints);

            // All endpoints are mapped directly in the main method now

            builder.AppendLine("    }");
            builder.AppendLine("}");

            var result = SourceText.From(builder.ToString(), Encoding.UTF8);
            System.Diagnostics.Debug.WriteLine("üöÄ SmartEndpointExtensionGenerator.GenerateCode completed!");
            return result;
        }

        private List<ControllerMetadata> DiscoverControllers(Compilation compilation)
        {
            var controllers = new List<ControllerMetadata>();

            foreach (var syntaxTree in compilation.SyntaxTrees)
            {
                var semanticModel = compilation.GetSemanticModel(syntaxTree);
                var root = syntaxTree.GetRoot();

                // Find classes with [AutoGenerateEndpoints]
                var classDeclarations = root.DescendantNodes()
                    .OfType<ClassDeclarationSyntax>();

                foreach (var classDecl in classDeclarations)
                {
                    var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
                    if (classSymbol == null) continue;

                    // Check for AutoGenerateEndpoints attribute
                    var hasAutoGenerate = classSymbol.GetAttributes()
                        .Any(a => a.AttributeClass?.Name == "AutoGenerateEndpointsAttribute");

                    if (!hasAutoGenerate)
                    {
                        // Also check for individual methods with AutoMapEndpoint
                        var hasMappedMethods = classDecl.Members
                            .OfType<MethodDeclarationSyntax>()
                            .Any(m => m.AttributeLists
                                .SelectMany(al => al.Attributes)
                                .Any(a => a.Name.ToString().Contains("AutoMapEndpoint")));

                        if (!hasMappedMethods) continue;
                    }

                    var controller = ExtractControllerMetadata(classDecl, classSymbol, semanticModel);
                    if (controller.Endpoints.Any())
                    {
                        controllers.Add(controller);
                    }
                }
            }

            return controllers;
        }

        private ControllerMetadata ExtractControllerMetadata(
            ClassDeclarationSyntax classDecl,
            INamedTypeSymbol classSymbol,
            SemanticModel semanticModel)
        {
            var controller = new ControllerMetadata
            {
                ClassName = classSymbol.Name,
                Namespace = classSymbol.ContainingNamespace?.ToDisplayString() ?? "Global"
            };

            // Extract class-level attributes
            var autoGenAttr = classSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "AutoGenerateEndpointsAttribute");

            if (autoGenAttr != null)
            {
                controller.HasAutoGenerateAttribute = true;
                
                // Extract RoutePrefix
                var routePrefix = autoGenAttr.NamedArguments
                    .FirstOrDefault(kv => kv.Key == "RoutePrefix").Value.Value?.ToString();
                
                controller.RoutePrefix = routePrefix ?? InferRoutePrefix(classSymbol.Name);
            }

            // Discover endpoint methods
            foreach (var methodDecl in classDecl.Members.OfType<MethodDeclarationSyntax>())
            {
                var methodSymbol = semanticModel.GetDeclaredSymbol(methodDecl);
                if (methodSymbol == null || !methodSymbol.DeclaredAccessibility.HasFlag(Accessibility.Public))
                    continue;

                var endpoint = ExtractEndpointMetadata(methodDecl, methodSymbol, controller);
                if (endpoint != null)
                {
                    controller.Endpoints.Add(endpoint);
                }
            }

            return controller;
        }

        private EndpointMetadata? ExtractEndpointMetadata(
            MethodDeclarationSyntax methodDecl,
            IMethodSymbol methodSymbol,
            ControllerMetadata controller)
        {
            // Check if method returns Result<T> or OneOf<...>
            var returnType = methodSymbol.ReturnType;
            var returnTypeName = returnType.ToDisplayString();

            var isResult = returnTypeName.StartsWith("REslava.Result.Result<");
            var isOneOf = returnTypeName.Contains("REslava.Result.AdvancedPatterns.OneOf<");

            if (!isResult && !isOneOf)
                return null;

            var endpoint = new EndpointMetadata
            {
                MethodName = methodSymbol.Name,
                ClassName = controller.ClassName,
                Namespace = controller.Namespace,
                ReturnType = returnTypeName,
                IsResult = isResult,
                IsOneOf = isOneOf
            };

            // Extract generic type arguments
            if (returnType is INamedTypeSymbol namedType && namedType.IsGenericType)
            {
                endpoint.GenericTypeArguments = namedType.TypeArguments
                    .Select(t => t.ToDisplayString())
                    .ToList();
            }

            // Check for AutoMapEndpoint attribute
            var mapAttr = methodSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "AutoMapEndpointAttribute");

            if (mapAttr != null)
            {
                // Extract explicit mapping
                endpoint.Route = mapAttr.ConstructorArguments.FirstOrDefault().Value?.ToString() ?? "";
                
                var httpMethod = mapAttr.NamedArguments
                    .FirstOrDefault(kv => kv.Key == "HttpMethod").Value.Value?.ToString();
                endpoint.HttpMethod = httpMethod ?? InferHttpMethod(methodSymbol.Name);
            }
            else if (controller.HasAutoGenerateAttribute)
            {
                // Infer from convention
                endpoint.Route = InferRoute(methodSymbol.Name, controller.RoutePrefix);
                endpoint.HttpMethod = InferHttpMethod(methodSymbol.Name);
            }
            else
            {
                return null; // Not mapped
            }

            // Extract parameters
            endpoint.Parameters = methodSymbol.Parameters
                .Select(p => new ParameterMetadata
                {
                    Name = p.Name,
                    Type = p.Type.ToDisplayString(),
                    Source = InferParameterSource(p, endpoint.HttpMethod)
                })
                .ToList();

            return endpoint;
        }

        private string InferRoutePrefix(string className)
        {
            // UserController ‚Üí /user, ProductService ‚Üí /product
            var name = className
                .Replace("Controller", "")
                .Replace("Service", "")
                .Replace("Endpoints", "");

            return $"/{name.ToLowerInvariant()}";
        }

        private string InferRoute(string methodName, string prefix)
        {
            // GetUser(int id) ‚Üí /user/{id}
            // GetUserById(int id) ‚Üí /user/{id}
            // CreateUser ‚Üí /user
            // UpdateUser(int id) ‚Üí /user/{id}

            var hasIdParam = methodName.Contains("ById") || methodName.Contains("By");
            
            if (methodName.StartsWith("Get") && hasIdParam)
                return $"{prefix}/{{id}}";
            
            if (methodName.StartsWith("Update") || methodName.StartsWith("Delete"))
                return $"{prefix}/{{id}}";

            return prefix;
        }

        private string InferHttpMethod(string methodName)
        {
            if (methodName.StartsWith("Get") || methodName.StartsWith("Find") || methodName.StartsWith("Search"))
                return "GET";
            if (methodName.StartsWith("Create") || methodName.StartsWith("Add"))
                return "POST";
            if (methodName.StartsWith("Update") || methodName.StartsWith("Modify"))
                return "PUT";
            if (methodName.StartsWith("Patch"))
                return "PATCH";
            if (methodName.StartsWith("Delete") || methodName.StartsWith("Remove"))
                return "DELETE";

            return "GET";
        }

        private ParameterSource InferParameterSource(IParameterSymbol param, string httpMethod)
        {
            // Simple heuristic: id from route, request objects from body, others from query
            if (param.Name.Equals("id", System.StringComparison.OrdinalIgnoreCase))
                return ParameterSource.Route;

            if (httpMethod == "POST" || httpMethod == "PUT" || httpMethod == "PATCH")
            {
                // Complex types go to body
                if (!param.Type.IsValueType && param.Type.SpecialType == SpecialType.None)
                    return ParameterSource.Body;
            }

            return ParameterSource.Query;
        }

        private void GenerateMapSmartEndpointsMethod(StringBuilder builder, List<EndpointMetadata> endpoints)
        {
            builder.AppendLine("        /// <summary>");
            builder.AppendLine("        /// Maps all auto-discovered SmartEndpoints to the application.");
            builder.AppendLine("        /// </summary>");
            builder.AppendLine("        public static IEndpointRouteBuilder MapSmartEndpoints(this IEndpointRouteBuilder endpoints)");
            builder.AppendLine("        {");
            builder.AppendLine("            // DEBUG: SmartEndpoints registration started");
            builder.AppendLine("            endpoints.MapGet(\"/api/smarttest/debug\", () => Results.Ok(new { message = \"SmartEndpoints method called!\" }));");
            
            foreach (var endpoint in endpoints)
            {
                // Generate individual endpoint mapping directly
                GenerateEndpointMappingSimple(builder, endpoint);
            }
            
            builder.AppendLine("            // DEBUG: SmartEndpoints registration completed");
            builder.AppendLine("            return endpoints;");
            builder.AppendLine("        }");
            builder.AppendLine();
        }

        private void GenerateControllerMappingMethod(StringBuilder builder, ControllerMetadata controller)
        {
            builder.AppendLine($"        /// <summary>");
            builder.AppendLine($"        /// Maps endpoints for {controller.ClassName}.");
            builder.AppendLine($"        /// </summary>");
            builder.AppendLine($"        public static IEndpointRouteBuilder Map{controller.ClassName}Endpoints(this IEndpointRouteBuilder endpoints)");
            builder.AppendLine("        {");

            foreach (var endpoint in controller.Endpoints)
            {
                GenerateEndpointMapping(builder, endpoint, controller);
            }

            builder.AppendLine("            return endpoints;");
            builder.AppendLine("        }");
            builder.AppendLine();
        }

        private void GenerateEndpointMapping(StringBuilder builder, EndpointMetadata endpoint, ControllerMetadata controller)
        {
            var httpMethod = endpoint.HttpMethod.ToUpperInvariant();
            var mapMethod = httpMethod switch
            {
                "GET" => "MapGet",
                "POST" => "MapPost",
                "PUT" => "MapPut",
                "PATCH" => "MapPatch",
                "DELETE" => "MapDelete",
                _ => "MapGet"
            };

            // Build parameter list
            var paramList = string.Join(", ", endpoint.Parameters.Select(p =>
            {
                var source = p.Source switch
                {
                    ParameterSource.Route => "",
                    ParameterSource.Body => "",
                    ParameterSource.Query => "",
                    _ => ""
                };
                return $"{p.Type} {p.Name}";
            }));

            // Build argument passing
            var argList = string.Join(", ", endpoint.Parameters.Select(p => p.Name));

            builder.AppendLine($"            endpoints.{mapMethod}(\"{endpoint.Route}\", ({paramList}) =>");
            builder.AppendLine("            {");
            builder.AppendLine($"                var controller = new {controller.Namespace}.{controller.ClassName}();");
            builder.AppendLine($"                var result = controller.{endpoint.MethodName}({argList});");
            
            // Convert to IResult
            if (endpoint.IsResult)
            {
                builder.AppendLine("                return result.ToIResult();");
            }
            else if (endpoint.IsOneOf)
            {
                builder.AppendLine("                return result.ToIResult();");
            }

            builder.AppendLine("            });");
            builder.AppendLine();
        }

        private void GenerateEndpointMappingSimple(StringBuilder builder, EndpointMetadata endpoint)
        {
            var httpMethod = endpoint.HttpMethod.ToUpperInvariant();
            var mapMethod = httpMethod switch
            {
                "GET" => "MapGet",
                "POST" => "MapPost", 
                "PUT" => "MapPut",
                "PATCH" => "MapPatch",
                "DELETE" => "MapDelete",
                _ => "MapGet"
            };

            // Build parameter list from endpoint metadata
            var paramList = string.Join(", ", endpoint.Parameters.Select(p => $"{p.Type} {p.Name}"));
            var argList = string.Join(", ", endpoint.Parameters.Select(p => p.Name));

            builder.AppendLine($"            endpoints.{mapMethod}(\"{endpoint.Route}\", ({paramList}) =>");
            builder.AppendLine("            {");
            builder.AppendLine($"                try {{");
            builder.AppendLine($"                    var controller = new MinimalApi.Net10.REslavaResult.Controllers.{endpoint.ClassName}();");
            builder.AppendLine($"                    var result = controller.{endpoint.MethodName}({argList});");
            
            // Determine the appropriate extension method based on the return type
            if (endpoint.ReturnType.Contains("OneOf<") && endpoint.ReturnType.Count(c => c == ',') == 1)
            {
                // OneOf<T1,T2> - use OneOfExtensions
                builder.AppendLine($"                    return result.ToIResult();");
            }
            else if (endpoint.ReturnType.Contains("OneOf<") && endpoint.ReturnType.Count(c => c == ',') == 2)
            {
                // OneOf<T1,T2,T3> - use OneOf3Extensions  
                builder.AppendLine($"                    return result.ToIResult();");
            }
            else if (endpoint.ReturnType.Contains("Result<"))
            {
                // Result<T> - use ToIResult extension
                builder.AppendLine($"                    return result.ToIResult();");
            }
            else
            {
                // Fallback for other types
                builder.AppendLine($"                    return Results.Ok(result);");
            }
            
            builder.AppendLine($"                }} catch (System.Exception ex) {{");
            builder.AppendLine($"                    return Results.Problem($\"Error in {endpoint.MethodName}: {{ex.Message}}\");");
            builder.AppendLine($"                }}");
            builder.AppendLine("            });");
            builder.AppendLine();
        }
    }
}
