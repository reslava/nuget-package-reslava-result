using Microsoft.CodeAnalysis;
using REslava.Result.SourceGenerators.Core.OneOf.Models;
using REslava.Result.SourceGenerators.Core.OneOf.Utilities;
using REslava.Result.SourceGenerators.Generators.OneOfToIResult.CodeGeneration.Interfaces;
using System.Text;

namespace REslava.Result.SourceGenerators.Generators.OneOfToIResult.CodeGeneration;

/// <summary>
/// Generates OneOf extension method code.
/// Single Responsibility: Only generates extension methods.
/// Following the same pattern as ResultToIResultExtensionGenerator.
/// </summary>
public class OneOfExtensionGenerator : IOneOfCodeGenerator
{
    /// <summary>
    /// Generates extension methods for OneOf types.
    /// </summary>
    public string GenerateExtensionMethods(OneOfGenerationContext context)
    {
        var builder = new StringBuilder();
        var oneOfTypeFullName = context.OneOfTypeInfo.FullName; // Use full name to avoid namespace conflicts
        var typeArgs = context.OneOfTypeInfo.TypeArguments;
        var mappings = context.MappingResults;

        // Generate ToIResult method
        GenerateToIResultMethod(builder, context, oneOfTypeFullName, typeArgs, mappings);

        if (context.Config.GenerateAllHttpMethods)
        {
            // Generate other HTTP methods in Phase 2
            // For now, just ToIResult for Phase 1
        }

        return builder.ToString();
    }

    /// <summary>
    /// Generates the main class structure for OneOf extension methods.
    /// </summary>
    public string GenerateClassStructure(OneOfGenerationContext context)
    {
        var className = GenerateUniqueClassName(context.OneOfTypeInfo);
        var usingStatements = GenerateUsingStatements(context);
        var extensionMethods = GenerateExtensionMethods(context);

        return $@"
{usingStatements}

namespace Generated.OneOfExtensions
{{
    /// <summary>
    /// Extension methods for {context.OneOfTypeInfo.FullName}.
    /// Automatically generated by REslava.Result.SourceGenerators.
    /// </summary>
    public static class {className}
    {{
        {extensionMethods}
    }}
}}";
    }

    /// <summary>
    /// Generates a unique class name based on the OneOf type arguments.
    /// </summary>
    private static string GenerateUniqueClassName(OneOfTypeInfo oneOfTypeInfo)
    {
        var typeNames = oneOfTypeInfo.TypeArguments
            .Select(OneOfTypeHelper.GetCleanTypeName)
            .Select(name => name.Replace("<", "_").Replace(">", "_").Replace(",", "_"))
            .Select(name => name.Replace(" ", "_"))
            .ToArray();

        return $"OneOf{string.Join("", typeNames)}Extensions";
    }

    /// <summary>
    /// Generates using statements for the generated code.
    /// </summary>
    public string GenerateUsingStatements(OneOfGenerationContext context)
    {
        var builder = new StringBuilder();
        
        builder.AppendLine("using Microsoft.AspNetCore.Http;");
        builder.AppendLine("using Microsoft.AspNetCore.Mvc;");
        builder.AppendLine("using System.Linq;");
        
        // Add using statements for each type argument
        var namespaces = context.OneOfTypeInfo.TypeArguments
            .Select(t => t.ContainingNamespace?.ToString())
            .Distinct()
            .Where(ns => !string.IsNullOrEmpty(ns));

        foreach (var ns in namespaces)
        {
            builder.AppendLine($"using {ns};");
        }

        return builder.ToString();
    }

    /// <summary>
    /// Generates the ToIResult method for a specific OneOf type.
    /// </summary>
    private static void GenerateToIResultMethod(
        StringBuilder builder,
        OneOfGenerationContext context,
        string oneOfTypeName,
        IReadOnlyList<ITypeSymbol> typeArgs,
        IReadOnlyList<OneOfMappingResult> mappings)
    {
        builder.AppendLine("        /// <summary>");
        builder.AppendLine($"        /// Converts {oneOfTypeName} to IResult with intelligent HTTP mapping.");
        
        // Add documentation for each mapping
        for (int i = 0; i < typeArgs.Count; i++)
        {
            var typeArg = typeArgs[i];
            var mapping = mappings[i];
            var cleanTypeName = OneOfTypeHelper.GetCleanTypeName(typeArg);
            var safeTypeName = cleanTypeName.Replace(",", ", ").Replace("<", "&lt;").Replace(">", "&gt;");
            builder.AppendLine($"        /// {safeTypeName} â†’ {mapping.StatusCode} ({mapping.ResponseType})");
        }
        
        builder.AppendLine("        /// </summary>");
        builder.AppendLine($"        public static IResult ToIResult(this {oneOfTypeName} oneOf)");
        builder.AppendLine("        {");
        builder.AppendLine("            return oneOf.Match(");

        // Generate Match cases
        for (int i = 0; i < typeArgs.Count; i++)
        {
            var typeArg = typeArgs[i];
            var mapping = mappings[i];
            var variableName = mapping.VariableName;
            var isLast = i == typeArgs.Count - 1;

            // Generate the case
            builder.Append($"                {variableName} => ");
            builder.Append(GenerateResponseCode(mapping, variableName));

            if (!isLast)
                builder.AppendLine(",");
            else
                builder.AppendLine();
        }

        builder.AppendLine("            );");
        builder.AppendLine("        }");
        builder.AppendLine();
    }

    /// <summary>
    /// Generates the response code for a specific mapping.
    /// </summary>
    private static string GenerateResponseCode(OneOfMappingResult mapping, string variableName)
    {
        return mapping.ResponseType switch
        {
            "Ok" => $"Results.Ok({variableName})",
            "Created" => GenerateCreatedResponse(mapping, variableName),
            "NotFound" => GenerateNotFoundResponse(mapping, variableName),
            "BadRequest" => GenerateBadRequestResponse(mapping, variableName),
            "Unauthorized" => $"Results.Unauthorized()",
            "Forbidden" => $"Results.Forbidden()",
            "Conflict" => $"Results.Conlict()",
            "UnprocessableEntity" => $"Results.UnprocessableEntity()",
            "NoContent" => $"Results.NoContent()",
            "InternalServerError" => $"Results.Problem(\"Internal server error\", statusCode: 500)",
            "ServiceUnavailable" => $"Results.Problem(\"Service unavailable\", statusCode: 503)",
            _ => $"Results.Problem(\"Error occurred\", statusCode: {mapping.StatusCode})"
        };
    }

    /// <summary>
    /// Generates a Created response with location template.
    /// </summary>
    private static string GenerateCreatedResponse(OneOfMappingResult mapping, string variableName)
    {
        if (!string.IsNullOrEmpty(mapping.LocationTemplate))
        {
            return $"Results.Created(\"{mapping.LocationTemplate}\", {variableName})";
        }
        
        // For now, use a default location pattern
        // In Phase 2, we can add more sophisticated location inference
        return $"Results.Created($\"/api/items/{{Guid.NewGuid()}}\", {variableName})";
    }

    /// <summary>
    /// Generates a NotFound response with error message.
    /// </summary>
    private static string GenerateNotFoundResponse(OneOfMappingResult mapping, string variableName)
    {
        if (mapping.IncludeProblemDetails)
        {
            return $"Results.NotFound({variableName}.Message)";
        }
        return "Results.NotFound()";
    }

    /// <summary>
    /// Generates a BadRequest response with error details.
    /// </summary>
    private static string GenerateBadRequestResponse(OneOfMappingResult mapping, string variableName)
    {
        if (mapping.IncludeProblemDetails)
        {
            return $"Results.Problem({variableName}.Message, statusCode: {mapping.StatusCode})";
        }
        return $"Results.Problem(\"Bad request\", statusCode: {mapping.StatusCode})";
    }
}
