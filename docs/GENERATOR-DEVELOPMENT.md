# Generator Development Guide

## üéØ Overview

This guide teaches you how to create custom source generators using the REslava.Result Core Library infrastructure. The Core Library provides reusable components that make generator development dramatically simpler and more maintainable.

## üèóÔ∏è Core Library Architecture

### **üì¶ Available Components**

| Component | Purpose | Key Features |
|-----------|---------|--------------|
| **IncrementalGeneratorBase<TConfig>** | Base class for generators | Configuration-driven, validation, cloning |
| **CodeBuilder** | Fluent code generation | Proper indentation, XML comments, method declarations |
| **HttpStatusCodeMapper** | HTTP status mapping | Convention-based, custom mappings, null safety |
| **AttributeParser** | Configuration parsing | Array handling, type safety, error validation |
| **GeneratorConfigurationBase<TConfig>** | Configuration base class | Validation, cloning, defaults |

---

## üöÄ Creating Your First Generator

### **Step 1: Create Configuration Class**

```csharp
using REslava.Result.SourceGenerators.Core.Configuration;

public class MyGeneratorConfig : GeneratorConfigurationBase<MyGeneratorConfig>
{
    /// <summary>
    /// Namespace for generated code
    /// </summary>
    public string Namespace { get; set; } = "Generated";
    
    /// <summary>
    /// Class name for generated code
    /// </summary>
    public string ClassName { get; set; } = "GeneratedExtensions";
    
    /// <summary>
    /// Whether to include XML documentation
    /// </summary>
    public bool IncludeXmlDocumentation { get; set; } = true;
    
    /// <summary>
    /// Custom prefix for generated methods
    /// </summary>
    public string MethodPrefix { get; set; } = "Generated";
    
    /// <summary>
    /// Validate configuration
    /// </summary>
    public override bool Validate()
    {
        return !string.IsNullOrEmpty(Namespace) &&
               !string.IsNullOrEmpty(ClassName) &&
               !Namespace.Contains(" ") &&
               ClassName.IsValidCSharpIdentifier();
    }
    
    /// <summary>
    /// Create deep clone of configuration
    /// </summary>
    public override object Clone()
    {
        return new MyGeneratorConfig
        {
            Namespace = Namespace,
            ClassName = ClassName,
            IncludeXmlDocumentation = IncludeXmlDocumentation,
            MethodPrefix = MethodPrefix
        };
    }
}
```

### **Step 2: Create Generator Class**

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using REslava.Result.SourceGenerators.Core.Infrastructure;
using REslava.Result.SourceGenerators.Core.CodeGeneration;

[Generator]
public class MyGenerator : IncrementalGeneratorBase<MyGeneratorConfig>
{
    /// <summary>
    /// Create default configuration
    /// </summary>
    protected override MyGeneratorConfig CreateDefaultConfig()
    {
        return new MyGeneratorConfig();
    }
    
    /// <summary>
    /// Generate source code
    /// </summary>
    protected override void GenerateCode(CodeGenerationContext context, MyGeneratorConfig config)
    {
        // Validate configuration
        if (!config.Validate())
        {
            ReportConfigurationError(context, config);
            return;
        }
        
        // Generate the main extension class
        GenerateExtensionClass(context, config);
        
        // Generate helper methods if needed
        if (config.IncludeXmlDocumentation)
        {
            GenerateHelperMethods(context, config);
        }
    }
    
    private void GenerateExtensionClass(CodeGenerationContext context, MyGeneratorConfig config)
    {
        var builder = new CodeBuilder();
        
        // Add namespace
        builder.AppendLine($"namespace {config.Namespace}")
               .OpenBrace();
        
        // Add class declaration
        builder.AppendClassDeclaration(config.ClassName, "public", "static");
        
        // Add XML documentation for class
        if (config.IncludeXmlDocumentation)
        {
            builder.AppendXmlSummary($"Generated extension methods for {config.ClassName}")
                   .AppendLine($"/// <para>")
                   .AppendLine($"/// This class contains auto-generated extension methods.")
                   .AppendLine($"/// Generated by REslava.Result Source Generator")
                   .AppendLine($"/// </para>");
        }
        
        builder.OpenBrace();
        
        // Generate extension methods
        GenerateExtensionMethods(builder, config);
        
        builder.CloseBrace(); // class
        builder.CloseBrace(); // namespace
        
        // Add the generated source
        var fileName = $"{config.ClassName}.g.cs";
        context.AddSource(fileName, builder.ToString());
    }
    
    private void GenerateExtensionMethods(CodeBuilder builder, MyGeneratorConfig config)
    {
        // Example: Generate a ToCustomString extension method
        builder.BlankLine()
               .AppendMethodDeclaration(
                   $"{config.MethodPrefix}ToCustomString",
                   "string",
                   "this object obj",
                   null,
                   "public", "static");
        
        if (config.IncludeXmlDocumentation)
        {
            builder.AppendXmlSummary("Converts object to custom string representation")
                   .AppendLine("/// <param name=\"obj\">The object to convert</param>")
                   .AppendLine("/// <returns>Custom string representation</returns>");
        }
        
        builder.AppendLine("if (obj == null) return \"[null]\";")
               .AppendLine($"return $\"[{config.MethodPrefix}] {{obj}}\";")
               .CloseBrace(); // method
    }
    
    private void GenerateHelperMethods(CodeGenerationContext context, MyGeneratorConfig config)
    {
        var builder = new CodeBuilder();
        
        builder.AppendLine($"namespace {config.Namespace}")
               .OpenBrace()
               .AppendClassDeclaration($"{config.ClassName}Helpers", "internal", "static")
               .OpenBrace()
               .AppendMethodDeclaration(
                   "IsValidCSharpIdentifier",
                   "bool",
                   "string identifier",
                   null,
                   "internal", "static")
               .AppendLine("if (string.IsNullOrEmpty(identifier)) return false;")
               .AppendLine("return !char.IsDigit(identifier[0]) && identifier.All(c => char.IsLetterOrDigit(c) || c == '_');")
               .CloseBrace() // method
               .CloseBrace() // class
               .CloseBrace(); // namespace
        
        context.AddSource($"{config.ClassName}Helpers.g.cs", builder.ToString());
    }
    
    private void ReportConfigurationError(CodeGenerationContext context, MyGeneratorConfig config)
    {
        var errors = GetValidationErrors(config);
        var errorMessage = string.Join(", ", errors);
        
        context.ReportDiagnostic(Diagnostic.Create(
            new DiagnosticDescriptor(
                "MG001", 
                "MyGenerator Configuration Error",
                "MyGenerator configuration is invalid: {0}",
                "MyGenerator",
                DiagnosticSeverity.Error,
                true),
            Location.None,
            errorMessage));
    }
}
```

### **Step 3: Create Attribute Class**

```csharp
using System;

namespace REslava.Result.SourceGenerators
{
    /// <summary>
    /// Enables MyGenerator for the assembly
    /// </summary>
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)]
    public sealed class GenerateMyExtensionsAttribute : Attribute
    {
        /// <summary>
        /// Namespace for generated code
        /// </summary>
        public string Namespace { get; set; } = "Generated";
        
        /// <summary>
        /// Class name for generated code
        /// </summary>
        public string ClassName { get; set; } = "GeneratedExtensions";
        
        /// <summary>
        /// Whether to include XML documentation
        /// </summary>
        public bool IncludeXmlDocumentation { get; set; } = true;
        
        /// <summary>
        /// Custom prefix for generated methods
        /// </summary>
        public string MethodPrefix { get; set; } = "Generated";
    }
}
```

---

## üéØ Advanced Generator Patterns

### **Pattern 1: Multiple Output Files**

```csharp
protected override void GenerateCode(CodeGenerationContext context, MyGeneratorConfig config)
{
    // Generate main extensions
    GenerateMainExtensions(context, config);
    
    // Generate helper classes
    GenerateHelpers(context, config);
    
    // Generate configuration classes
    GenerateConfiguration(context, config);
}

private void GenerateMainExtensions(CodeGenerationContext context, MyGeneratorConfig config)
{
    var builder = new CodeBuilder();
    // ... generate main extensions
    context.AddSource("MainExtensions.g.cs", builder.ToString());
}

private void GenerateHelpers(CodeGenerationContext context, MyGeneratorConfig config)
{
    var builder = new CodeBuilder();
    // ... generate helpers
    context.AddSource("Helpers.g.cs", builder.ToString());
}
```

### **Pattern 2: Using HttpStatusCodeMapper**

```csharp
private void GenerateErrorHandling(CodeBuilder builder, MyGeneratorConfig config)
{
    var mapper = new HttpStatusCodeMapper(config.DefaultErrorStatusCode);
    
    // Add custom mappings
    if (config.CustomErrorMappings?.Length > 0)
    {
        mapper.AddMappings(config.CustomErrorMappings);
    }
    
    builder.AppendLine("private static int GetErrorCode(Exception ex)")
           .OpenBrace()
           .AppendLine("var errorType = ex.GetType().Name;")
           .AppendLine($"return errorType switch")
           .OpenBrace();
    
    // Add convention-based mappings
    var commonErrors = new[]
    {
        ("NotFoundException", 404),
        ("ValidationException", 422),
        ("UnauthorizedException", 401),
        ("ForbiddenException", 403)
    };
    
    foreach (var (errorName, statusCode) in commonErrors)
    {
        builder.AppendLine($"\"{errorName}\" => {statusCode},");
    }
    
    builder.AppendLine("_ => 400")
           .CloseBrace() // switch
           .AppendLine(";")
           .CloseBrace(); // method
}
```

### **Pattern 3: Configuration Validation**

```csharp
public class AdvancedGeneratorConfig : GeneratorConfigurationBase<AdvancedGeneratorConfig>
{
    public string Namespace { get; set; } = "Generated";
    public string ClassName { get; set; } = "Extensions";
    public string[] TargetTypes { get; set; } = Array.Empty<string>();
    public bool GenerateAsync { get; set; } = true;
    public bool GenerateSync { get; set; } = true;
    public int MaxMethods { get; set; } = 100;
    
    public override bool Validate()
    {
        return !string.IsNullOrEmpty(Namespace) &&
               !string.IsNullOrEmpty(ClassName) &&
               Namespace.IsValidCSharpIdentifier() &&
               ClassName.IsValidCSharpIdentifier() &&
               TargetTypes?.Length > 0 &&
               TargetTypes.All(t => !string.IsNullOrEmpty(t)) &&
               MaxMethods > 0 &&
               (GenerateAsync || GenerateSync); // At least one should be enabled
    }
    
    public override object Clone()
    {
        return new AdvancedGeneratorConfig
        {
            Namespace = Namespace,
            ClassName = ClassName,
            TargetTypes = (string[])TargetTypes?.Clone(),
            GenerateAsync = GenerateAsync,
            GenerateSync = GenerateSync,
            MaxMethods = MaxMethods
        };
    }
}
```

---

## üß™ Testing Your Generator

### **Unit Tests**

```csharp
[TestClass]
public class MyGeneratorTests
{
    [TestMethod]
    public void Generator_Instantiation_ShouldWork()
    {
        // Arrange & Act
        var generator = new MyGenerator();
        
        // Assert
        Assert.IsNotNull(generator);
        Assert.IsTrue(generator is IIncrementalGenerator);
    }
    
    [TestMethod]
    public void Configuration_DefaultValues_ShouldBeCorrect()
    {
        // Arrange & Act
        var config = new MyGeneratorConfig();
        
        // Assert
        Assert.AreEqual("Generated", config.Namespace);
        Assert.AreEqual("GeneratedExtensions", config.ClassName);
        Assert.IsTrue(config.IncludeXmlDocumentation);
        Assert.AreEqual("Generated", config.MethodPrefix);
    }
    
    [TestMethod]
    public void Configuration_Validation_ShouldWork()
    {
        // Arrange
        var validConfig = new MyGeneratorConfig
        {
            Namespace = "Test.Generated",
            ClassName = "TestExtensions"
        };
        
        var invalidConfig = new MyGeneratorConfig
        {
            Namespace = "", // Invalid
            ClassName = "TestExtensions"
        };
        
        // Act & Assert
        Assert.IsTrue(validConfig.Validate());
        Assert.IsFalse(invalidConfig.Validate());
    }
    
    [TestMethod]
    public void Configuration_Clone_ShouldCreateIndependentCopy()
    {
        // Arrange
        var original = new MyGeneratorConfig
        {
            Namespace = "Test.Generated",
            ClassName = "TestExtensions",
            MethodPrefix = "Custom"
        };
        
        // Act
        var clone = (MyGeneratorConfig)original.Clone();
        clone.Namespace = "Modified";
        
        // Assert
        Assert.AreNotEqual(original.Namespace, clone.Namespace);
        Assert.AreEqual("Test.Generated", original.Namespace);
    }
}
```

### **Integration Tests**

```csharp
[TestClass]
public class MyGeneratorIntegrationTests
{
    [TestMethod]
    public void Generator_WithValidConfig_ShouldGenerateCode()
    {
        // Arrange
        var config = new MyGeneratorConfig
        {
            Namespace = "Test.Generated",
            ClassName = "TestExtensions"
        };
        
        var generator = new MyGenerator();
        
        // Act
        var generatedCode = GenerateCode(generator, config);
        
        // Assert
        Assert.IsTrue(generatedCode.Contains("namespace Test.Generated"));
        Assert.IsTrue(generatedCode.Contains("public static class TestExtensions"));
        Assert.IsTrue(generatedCode.Contains("GeneratedToCustomString"));
    }
    
    private string GenerateCode(MyGenerator generator, MyGeneratorConfig config)
    {
        // This would typically involve creating a compilation context
        // and running the generator, then extracting the generated code
        // For demonstration, we'll return a mock result
        return "namespace Test.Generated { public static class TestExtensions { public static string GeneratedToCustomString(this object obj) => obj?.ToString() ?? \"[null]\"; } }";
    }
}
```

---

## üîß Best Practices

### **1. Configuration Design**

```csharp
// ‚úÖ Good: Sensible defaults
public class GoodConfig : GeneratorConfigurationBase<GoodConfig>
{
    public string Namespace { get; set; } = "Generated"; // Sensible default
    public bool IncludeDocumentation { get; set; } = true; // Most users want this
    public int MaxItems { get; set; } = 100; // Reasonable limit
}

// ‚ùå Bad: No defaults or poor defaults
public class BadConfig : GeneratorConfigurationBase<BadConfig>
{
    public string Namespace { get; set; } = ""; // Empty default
    public bool IncludeDocumentation { get; set; } = false; // Most users want this
    public int MaxItems { get; set; } = 0; // Useless default
}
```

### **2. Error Handling**

```csharp
// ‚úÖ Good: Graceful error handling
protected override void GenerateCode(CodeGenerationContext context, MyGeneratorConfig config)
{
    try
    {
        if (!config.Validate())
        {
            ReportConfigurationError(context, config);
            return;
        }
        
        GenerateCodeInternal(context, config);
    }
    catch (Exception ex)
    {
        context.ReportDiagnostic(Diagnostic.Create(
            new DiagnosticDescriptor("MG999", "Generator Error", 
                "Generator failed: {0}", "MyGenerator", DiagnosticSeverity.Error, true),
            Location.None, ex.Message));
    }
}

// ‚ùå Bad: No error handling
protected override void GenerateCode(CodeGenerationContext context, MyGeneratorConfig config)
{
    // This will crash the build if something goes wrong
    GenerateCodeInternal(context, config);
}
```

### **3. Code Generation**

```csharp
// ‚úÖ Good: Use CodeBuilder properly
private void GenerateMethod(CodeBuilder builder, string methodName)
{
    builder.AppendMethodDeclaration(methodName, "void", null, null, "public", "static")
           .AppendLine("// Method implementation")
           .CloseBrace();
}

// ‚ùå Bad: Manual string concatenation
private string GenerateMethod(string methodName)
{
    return $"public static void {methodName}() {{ // Method implementation }}";
}
```

### **4. Testing**

```csharp
// ‚úÖ Good: Comprehensive testing
[TestClass]
public class MyGeneratorTests
{
    [TestMethod]
    public void Configuration_Defaults_ShouldBeValid() { /* ... */ }
    
    [TestMethod]
    public void Configuration_Validation_ShouldCatchInvalidInput() { /* ... */ }
    
    [TestMethod]
    public void Configuration_Clone_ShouldBeIndependent() { /* ... */ }
    
    [TestMethod]
    public void Generator_WithValidConfig_ShouldGenerateExpectedCode() { /* ... */ }
    
    [TestMethod]
    public void Generator_WithInvalidConfig_ShouldReportError() { /* ... */ }
}

// ‚ùå Bad: Minimal or no testing
[TestClass]
public class MyGeneratorTests
{
    [TestMethod]
    public void Generator_ShouldWork() 
    {
        var generator = new MyGenerator();
        Assert.IsNotNull(generator);
    }
}
```

---

## üöÄ Performance Considerations

### **1. Incremental Generation**

```csharp
// ‚úÖ Good: Use incremental providers properly
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    var provider = context.SyntaxProvider
        .CreateSyntaxProvider(
            (node, _) => node is ClassDeclarationSyntax,
            (ctx, _) => GetSemanticInfo(ctx))
        .Where(static info => info.ShouldGenerate)
        .Collect();
    
    context.RegisterSourceOutput(provider, (ctx, source) => 
        GenerateCode(ctx, source));
}

// ‚ùå Bad: Generate on every compilation
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    context.RegisterSourceOutput(context.CompilationProvider, (ctx, compilation) =>
    {
        // This runs every time, even when nothing changed
        GenerateCodeForCompilation(ctx, compilation);
    });
}
```

### **2. Memory Usage**

```csharp
// ‚úÖ Good: Use StringBuilder and pooling
private string GenerateLargeCode(MyGeneratorConfig config)
{
    var builder = new StringBuilder();
    
    foreach (var item in config.Items)
    {
        builder.AppendLine($"public void Process{item.Name}() {{ /* implementation */ }}");
    }
    
    return builder.ToString();
}

// ‚ùå Bad: String concatenation in loops
private string GenerateLargeCode(MyGeneratorConfig config)
{
    string result = "";
    
    foreach (var item in config.Items)
    {
        result += $"public void Process{item.Name}() {{ /* implementation */ }}\n";
    }
    
    return result;
}
```

---

## üìÅ Project Structure

### **Recommended Structure for Your Generator**

```
MyGenerator/
‚îú‚îÄ‚îÄ MyGenerator.csproj              # Project file
‚îú‚îÄ‚îÄ MyGenerator.cs                  # Main generator class
‚îú‚îÄ‚îÄ MyGeneratorConfig.cs            # Configuration class
‚îú‚îÄ‚îÄ MyGeneratorAttribute.cs         # Assembly attribute
‚îú‚îÄ‚îÄ Tests/                          # Test project
‚îÇ   ‚îú‚îÄ‚îÄ MyGeneratorTests.cs         # Unit tests
‚îÇ   ‚îú‚îÄ‚îÄ MyGeneratorIntegrationTests.cs # Integration tests
‚îÇ   ‚îî‚îÄ‚îÄ TestModels.cs               # Test data
‚îî‚îÄ‚îÄ README.md                       # Generator documentation
```

### **Project File Template**

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <LangVersion>latest</LangVersion>
    <Nullable>enable</Nullable>
    <IncludeBuildOutput>false</IncludeBuildOutput>
    <SuppressDependenciesWhenPacking>true</SuppressDependenciesWhenPacking>
    <GeneratePackageOnBuild>false</GeneratePackageOnBuild>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.3.4" PrivateAssets="all" />
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.5.0" PrivateAssets="all" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="../Core/REslava.Result.SourceGenerators.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="analyzers/dotnet/cs" Visible="false" />
  </ItemGroup>
</Project>
```

---

## üéØ Advanced Topics

### **1. Custom Diagnostics**

```csharp
private void ReportCustomDiagnostic(CodeGenerationContext context, string message, string code = "MY001")
{
    var descriptor = new DiagnosticDescriptor(
        code,
        "MyGenerator Warning",
        message,
        "MyGenerator",
        DiagnosticSeverity.Warning,
        true);

    context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None));
}
```

### **2. File Generation**

```csharp
private void GenerateAdditionalFiles(CodeGenerationContext context, MyGeneratorConfig config)
{
    // Generate additional files
    var additionalFiles = new[]
    {
        ("Constants.g.cs", GenerateConstants(config)),
        ("Helpers.g.cs", GenerateHelpers(config)),
        ("Extensions.g.cs", GenerateExtensions(config))
    };

    foreach (var (fileName, content) in additionalFiles)
    {
        context.AddSource(fileName, content);
    }
}
```

### **3. Caching and Optimization**

```csharp
private static readonly ConcurrentDictionary<string, string> _templateCache = new();

private string GetCachedTemplate(string templateName)
{
    return _templateCache.GetOrAdd(templateName, name => LoadTemplate(name));
}
```

---

## üìö Additional Resources

- **[Core Library Documentation](CORE-LIBRARY.md)** - Detailed Core library guide
- **[Migration Guide](MIGRATION-v1.9.0.md)** - Migration from previous versions
- **[Testing Documentation](TESTING.md)** - Testing strategies and guidelines
- **[Roslyn Documentation](https://github.com/dotnet/roslyn)** - Official Roslyn documentation

---

## ü§ù Contributing

When contributing generators to the REslava.Result ecosystem:

1. **üß™ Comprehensive Testing** - Ensure 100% test coverage
2. **üìö Documentation** - Provide clear documentation and examples
3. **üîß Best Practices** - Follow established patterns and conventions
4. **‚úÖ Validation** - Ensure robust configuration validation
5. **üöÄ Performance** - Consider performance implications

---

## üìÑ License

Generators built with the REslava.Result Core Library inherit the MIT License from the parent project.

---

## üéâ Conclusion

The REslava.Result Core Library makes source generator development dramatically simpler and more maintainable. By leveraging the provided components and following the patterns outlined in this guide, you can create powerful, reliable generators with minimal effort.

**Happy generating!** üöÄ
